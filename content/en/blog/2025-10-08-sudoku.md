---
title: "Quantum Sudoku: collapsing, entangling, and sliding through universes"
linkTitle: "Quantum Sudoku"
date: 2025-10-08T00:00:00Z
authors:
  - baraban
  - llm-kun
---

# Quantum Sudoku: collapsing, entangling, and sliding through universes

> This is a thinking toy. I’m not proving physics with Sudoku; I’m using Sudoku to *feel* what the math is doing: superposition, collapse, entanglement, GHZ/W-style tripartite structure, Schrödinger’s box, decoherence, Many-Worlds, and “the future creating the past.”
> In the draft below I’ll put **demo parameters** instead of illustrations. Later we’ll swap them for live snippets, gifs, or short videos.

---

## Part I — The quantum cell

### 1) Observation and collapse (certainty first)

Start with a particle that’s already collapsed. In Sudoku-speak: a cell that has exactly one admissible state. When we click, we’re not discovering; we’re confirming.

<style>
  #p1_demo1 { height: 210px; }
</style>

<p id="p1_demo1" class="canvas"></p>

<script>
  // Single cell with a known definite state (certainty)
  const p1_1 = initSudoku("#p1_demo1", {
    subRows: 1, subCols: 1, singleSection: true,
    clickToSetAnswer: true, autoHints: true, autosolver: false
  });
  // Certainty: value exists before we look (we just reveal/confirm it)
  (function ensureCollapsed(){
    const b = p1_1.block("R1C1");
    if (b) { b.setValue(1); }
  })();
</script>

### 2) Superposition of two states

Now the cell is `{1,2}` until we look. Repeated resets + clicks let readers *feel* probability: same setup, different runs, different outcomes.

<style>
  #p1_demo2 { height: 210px; }
  #p1_demo2_controls .btn { background:#2b3036; color:var(--text); border:1px solid #5a646e; border-radius:10px; padding:6px 10px; cursor:pointer; }
  #p1_demo2_controls { display:flex; gap:8px; align-items:center; margin: 6px 0 2px 0; }
</style>

<div class="wrap">
  <div id="p1_demo2_controls">
    <button id="p1d2_reset" class="btn">Reset</button>
    <button id="p1d2_measure" class="btn">Measure (collapse)</button>
    <span class="hint" style="opacity:.75;font-size:13px;">State is {1,2} until measured.</span>
  </div>
</div>
<p id="p1_demo2" class="canvas"></p>

<script>
  // Single cell that collapses to 1 or 2 upon "measurement"
  const p1_2 = initSudoku("#p1_demo2", {
    subRows: 1, subCols: 1, singleSection: true,
    clickToSetAnswer: true, autoHints: true, autosolver: false,
    maxHint: 2
  });
  const p1_2_blk = () => p1_2.block("R1C1");
  function p1_2_reset(){
    const b = p1_2_blk();
    if (b) {
      b.setValue(null);
    }
  }
  function p1_2_measure(){
    const b = p1_2_blk(); if (!b) return;
    const v = Math.random() < 0.5 ? 1 : 2;
    b.setValue(v);
  }
  document.getElementById("p1d2_reset").addEventListener("click", p1_2_reset);
  document.getElementById("p1d2_measure").addEventListener("click", p1_2_measure);
  p1_2_reset();
</script>

### 3) Two independent particles

Two cells, both in superposition, but **not entangled**. Each collapses on its own timeline.

<style>
  #p1_demo3 { height: 210px; }
  #p1_demo3_controls .btn { background:#2b3036; color:var(--text); border:1px solid #5a646e; border-radius:10px; padding:6px 10px; cursor:pointer; }
  #p1_demo3_controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin: 6px 0 2px 0; }
</style>

<div class="wrap">
  <div id="p1_demo3_controls">
    <button id="p1d3_reset" class="btn">Reset both</button>
    <button id="p1d3_measureA" class="btn">Measure Left</button>
    <button id="p1d3_measureB" class="btn">Measure Right</button>
    <span class="hint" style="opacity:.75;font-size:13px;">Two cells, both {1,2}, but not entangled.</span>
  </div>
</div>
<p id="p1_demo3" class="canvas"></p>

<script>
  // Two independent cells (2×1, one section) that collapse separately
  const p1_3 = initSudoku("#p1_demo3", {
    subRows: 1, subCols: 2, singleSection: true,
    clickToSetAnswer: true, autoHints: false, autosolver: false
  });
  const P1A = "R1C1", P1B = "R1C2";
  const p1_3_blk = id => p1_3.block(id);
  function p1_3_reset(){
    const a = p1_3_blk(P1A), b = p1_3_blk(P1B);
    if (a) {
      a.setValue(null);
    }
    if (b) {
      b.setValue(null);
    }
  }
  function collapseTo12(block){
    const v = Math.random() < 0.5 ? 1 : 2;
    block.setValue(v);
  }
  document.getElementById("p1d3_reset").addEventListener("click", p1_3_reset);
  document.getElementById("p1d3_measureA").addEventListener("click", ()=>{ const a=p1_3_blk(P1A); if (a) collapseTo12(a); });
  document.getElementById("p1d3_measureB").addEventListener("click", ()=>{ const b=p1_3_blk(P1B); if (b) collapseTo12(b); });
  p1_3_reset();
</script>
---

## Part II — The rules of the universe (why correlations appear)

Sudoku’s laws are local: every row, column, and section must contain each number exactly once. Once we turn those on, cells start “talking” through constraints. That’s our bridge from “two dice” to “two qubits that care about each other.”

### 4) Turning on the laws

Even a 2×2 world shows how local consistency creates nonlocal *consequences*.

<style>
  #p2_demo4 { height: 420px; }
  #p2_demo4_controls .btn { background:#2b3036; color:var(--text); border:1px solid #5a646e; border-radius:10px; padding:6px 10px; cursor:pointer; }
  #p2_demo4_controls { display:flex; gap:8px; align-items:center; margin: 6px 0 2px 0; flex-wrap:wrap; }
</style>

<div class="wrap">
  <div id="p2_demo4_controls">
    <button id="p2d4_reset" class="btn">Reset</button>
    <span class="hint" style="opacity:.75;font-size:13px;">Observe how local rules enforce global order.</span>
  </div>
</div>
<p id="p2_demo4" class="canvas"></p>

<script>
  // Small 2×2 Sudoku – "local laws"
  const p2_4 = initSudoku("#p2_demo4", {
    subRows: 2, subCols: 2,
    singleSection: true,
    clickToSetAnswer: true,
    autoHints: true,
    autosolver: true
  });

  function p2_4_reset(){
    p2_4.sudoku.setAutosolver(false);
    const p2_4_blk = id => p2_4.block(id);
    // Reset all cells to superposition (null values)
    for (let row = 1; row <= 4; row++) {
      for (let col = 1; col <= 4; col++) {
        const cellId = `R${row}C${col}`;
        const cell = p2_4_blk(cellId);
        if (cell) {
          cell.setValue(null);
        }
      }
    }
    p2_4.sudoku.setAutosolver(true);
  }

  document.getElementById("p2d4_reset").addEventListener("click", p2_4_reset);
  document.getElementById("p2d4_autosolve").addEventListener("click", p2_4_autosolve);
  p2_4_reset();
</script>

### 5) Hidden order behind the chaos

A standard 9×9 Sudoku has a definite solution (a hidden global state). We perceive “superposition” only because we haven’t computed the solution yet. Cognitively, it *feels* quantum; ontologically, it’s classical determinism hiding in plain sight.

<style>
  #p2_demo5 { height: 600px; }
  #p2_demo5_controls .btn { background:#2b3036; color:var(--text); border:1px solid #5a646e; border-radius:10px; padding:6px 10px; cursor:pointer; }
  #p2_demo5_controls { display:flex; gap:8px; align-items:center; margin: 6px 0 2px 0; flex-wrap:wrap; }
</style>

<div class="wrap">
  <div id="p2_demo5_controls">
    <button id="p2d5_reset" class="btn">Reset</button>
    <span class="hint" style="opacity:.75;font-size:13px;">Hidden determinism: one unique 9×9 solution exists.</span>
  </div>
</div>
<p id="p2_demo5" class="canvas"></p>

<script>
  // Standard 9×9 Sudoku – hidden global order
  const p2_5 = initSudoku("#p2_demo5", {
    subRows: 3, subCols: 3,
    singleSection: false,
    clickToSetAnswer: true,
    autoHints: true,
    autosolver: false
  });

  function p2_5_reset(){
    p2_5.sudoku.setAutosolver(false);
    p2_5.sudoku.setAutoHints(false);
    const p2_5_blk = id => p2_5.block(id);
    // Reset all cells to superposition (null values)
    for (let row = 1; row <= 9; row++) {
      for (let col = 1; col <= 9; col++) {
        const cellId = `R${row}C${col}`;
        const cell = p2_5_blk(cellId);
        if (cell) {
          cell.setValue(null);
        }
      }
    }
    p2_5.sudoku.setAutoHints(true);
    p2_5.sudoku.setAutosolver(true);
    p2_5.sudoku.updateAllHints();
  }

  document.getElementById("p2d5_reset").addEventListener("click", p2_5_reset);
  p2_5_reset();
</script>

---

## Part III — Entanglement and partial observation

### 6) Two entangled particles (perfect anticorrelation)

Make a tiny universe where two cells must be different. Click one: the other is forced to the opposite value. This is the “wow” moment—measurement here shapes reality there.

<style>
  #p3_demo6 { height: 260px; }
  #p3_demo6_controls .btn {
    background:#2b3036; color:var(--text);
    border:1px solid #5a646e; border-radius:10px;
    padding:6px 10px; cursor:pointer;
  }
  #p3_demo6_controls {
    display:flex; flex-wrap:wrap; gap:8px;
    align-items:center; margin: 6px 0 2px 0;
  }
</style>

<div class="wrap">
  <div id="p3_demo6_controls">
    <button id="p3d6_reset" class="btn">Reset</button>
    <button id="p3d6_measureLeft" class="btn">Measure Left</button>
    <button id="p3d6_measureRight" class="btn">Measure Right</button>
    <span class="hint" style="opacity:.75;font-size:13px;">
      Two cells share one section and must be different (values {1,2}). Measure one → the other is forced.
    </span>
  </div>
</div>
<p id="p3_demo6" class="canvas"></p>

<script>
  // 2×1, one section, hints {1,2} ⇒ section constraint enforces "different"
  const p3_6 = initSudoku("#p3_demo6", {
    subRows: 1, subCols: 2, singleSection: true,
    maxHint: 2, clickToSetAnswer: true,
    autosolver: false, autoHints: true
  });

  const LEFT = "R1C1", RIGHT = "R1C2";
  const blk = id => p3_6.block(id);

  function reset_p3_6() {
    p3_6.sudoku.setAutoHints(false);
    const a = blk(LEFT), b = blk(RIGHT);
    if (a) a.setValue(null);
    if (b) b.setValue(null);
    p3_6.sudoku.updateAllHints();
    p3_6.sudoku.setAutoHints(true);
  }

  function collapseToOpposite(firstId) {
    const a = blk(firstId);
    // Trigger the click event to simulate user interaction and internal collapse
    a.g.dispatchEvent(new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window
    }));
  }

  document.getElementById("p3d6_reset").addEventListener("click", reset_p3_6);
  document.getElementById("p3d6_measureLeft").addEventListener("click", () => collapseToOpposite(LEFT));
  document.getElementById("p3d6_measureRight").addEventListener("click", () => collapseToOpposite(RIGHT));

  // Boot in the "all superposed" state
  reset_p3_6();
</script>

### 7) Entanglement with more than two states

Let each cell have four possibilities. A measurement on one cell doesn’t finish the job—it just prunes the other’s possibilities. The vibe is *partial collapse*.

<style>
  #p3_demo7 { height: 220px; }
  #p3_demo7_controls .btn {
    background:#2b3036; color:var(--text);
    border:1px solid #5a646e; border-radius:10px;
    padding:6px 10px; cursor:pointer;
  }
  #p3_demo7_controls {
    display:flex; flex-wrap:wrap; gap:8px;
    align-items:center; margin: 6px 0 6px 0;
  }
  #p3d7_status {
    font-size: 13px; opacity:.8; margin: 4px 0 0;
    display:flex; gap:12px; flex-wrap:wrap;
  }
  #p3d7_status code { padding:2px 6px; border:1px solid #5a646e; border-radius:8px; }
</style>

<div class="wrap">
  <div id="p3_demo7_controls">
    <button id="p3d7_reset" class="btn">Reset</button>
    <button id="p3d7_partialLeft"  class="btn">Partial Measure (Left)</button>
    <button id="p3d7_partialRight" class="btn">Partial Measure (Right)</button>
    <button id="p3d7_finalizeLeft"  class="btn">Finalize (Left)</button>
    <button id="p3d7_finalizeRight" class="btn">Finalize (Right)</button>
  </div>
</div>
  <p id="p3_demo7" class="canvas"></p>
  <p id="p3d7_status">
    <span>Left allowed:  <code id="p3d7_left"></code></span>
    <span>Right allowed: <code id="p3d7_right"></code></span>
    <br>
    <span class="hint">Partial measure ⇒ choose 2 at random; other cell gets the complement. Same section ⇒ final values must differ.</span>
  </p>

<script>
(function () {
   // --- Horizontal board: 1×2, single section, universe {1,2,3,4}
   const board = initSudoku("#p3_demo7", {
     subRows: 1, subCols: 2, singleSection: true,
     maxHint: 4, clickToSetAnswer: true,
     autoHints: true, autosolver: false,
     preferCustomHints: true
   });

  const L = "R1C1", R = "R1C2";
  const U = new Set([1,2,3,4]);

  const allowed = { [L]: new Set(U), [R]: new Set(U) };
  const blk = id => board.block(id);
  const $ = id => document.getElementById(id);
  const fmt = set => `{${[...set].join(",")}}`;
  function updateStatus() {
    $("p3d7_left").textContent  = fmt(allowed[L]);
    $("p3d7_right").textContent = fmt(allowed[R]);
  }

  function randInt(n){ return Math.floor(Math.random()*n); }
  function pickTwoRandom(set) {
    const arr = [...set];
    if (arr.length <= 2) return new Set(arr);
    // Fisher–Yates one-pass for first two
    for (let i = 0; i < 2; i++) {
      const j = i + randInt(arr.length - i);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return new Set([arr[0], arr[1]]);
  }
  function complementInUniverse(subset, universe) {
    const out = new Set();
    for (const v of universe) if (!subset.has(v)) out.add(v);
    return out;
  }

  function partialMeasure(targetId) {
    const otherId = targetId === L ? R : L;

    // 1) choose two at random from the *current* allowed set of the target
    const chosen = pickTwoRandom(allowed[targetId]);

    // 2) set target to that 2-set; 3) set the other to the exact complement in U
    allowed[targetId] = chosen;
    allowed[otherId]  = complementInUniverse(chosen, U);

    // ensure no concrete values yet
    const tb = blk(targetId), ob = blk(otherId);
    if (tb && tb._value != null) tb.setValue(null);
    if (ob && ob._value != null) ob.setValue(null);

    // Update hints to show the allowed values
    if (tb) tb.setHints([...chosen]);
    if (ob) ob.setHints([...allowed[otherId]]);

    updateStatus();
  }

  function finalize(id) {
    const set = allowed[id];
    if (!set || set.size === 0) return;

    const arr = [...set];
    const v = arr.length === 1 ? arr[0] : arr[randInt(arr.length)];
    const b = blk(id);
    if (b) b.setValue(v);

    // Same-section constraint: the other cannot be v
    const otherId = (id === L ? R : L);
    allowed[otherId].delete(v);

    // Update hints for the other cell to reflect the constraint
    const otherBlk = blk(otherId);
    if (otherBlk && otherBlk._value === null) {
      otherBlk.setHints([...allowed[otherId]]);
    }

    updateStatus();
  }

  function reset() {
    allowed[L] = new Set(U);
    allowed[R] = new Set(U);
    const lb = blk(L), rb = blk(R);
    if (lb) {
      lb.setValue(null);
      lb.setHints([...U]); // Show all possible values as hints
    }
    if (rb) {
      rb.setValue(null);
      rb.setHints([...U]); // Show all possible values as hints
    }
    updateStatus();
  }

  $("p3d7_reset").addEventListener("click", reset);
  $("p3d7_partialLeft").addEventListener("click",  () => partialMeasure(L));
  $("p3d7_partialRight").addEventListener("click", () => partialMeasure(R));
  $("p3d7_finalizeLeft").addEventListener("click",  () => finalize(L));
  $("p3d7_finalizeRight").addEventListener("click", () => finalize(R));

  reset();
})();
</script>

### 7.1) Multipartite entanglement (three particles, new phenomena)

Two bodies can correlate; three bodies can do *qualitatively new* things. With **3×1, one section, hints {1,2,3}**, we can show three different “tripartite flavors”:

**All-Distinct (Sudoku-native constraint).** Any click forces the remaining two to be the two other numbers (still undecided who is who until the next click).

**GHZ-like (all-match).** Only triplets (1,1,1), (2,2,2), (3,3,3) allowed. Measure one → all three lock.

**W-like (single excitation).** Only permutations of (3,1,1). If you see a `3` anywhere, the others must be `1`s; if you see a `1`, the lone `3` is still “somewhere else” (residual uncertainty survives a measurement).

**Demo params (base All-Distinct)**

```js
initSudoku("#p3_demo7a", {
  subRows: 3, subCols: 1, singleSection: true,
  maxHint: 3, clickToSetAnswer: true,
  autoHints: true, autosolver: false
});
```

**Optional hooks**

```js
// GHZ-like: after a value appears in any cell, set the others to the same value.
enforceGHZ(board_7b);

// W-like: enforce permutations of (3,1,1); if a cell becomes 3, set the others to 1.
// If a cell becomes 1, restrict others to {1,3} without fully collapsing them.
enforceW(board_7c);
```

### 8) Partial observation and decoherence (weak measurement vibe)

Sometimes you learn just enough to rule out half the story, but not enough to finish it. Clicks remove classes of hints on both sides without fixing a final value. That’s intuition for **decoherence**: coherence leaks; probabilities get “classical-ish,” yet the system isn’t fully collapsed.

**Demo params**

```js
initSudoku("#p3_demo8", {
  subRows: 2, subCols: 1, singleSection: true,
  maxHint: 4, clickToSetAnswer: true,
  autoHints: false
});
// click handler: remove two hints here and the complementary two there; keep values unset
```

---

## Part IV — Multiverse goggles

### 9) Many-Worlds vs true randomness vs hidden variables

Take an entangled 2×1 pair and put two boards side-by-side. In one, the first click yields `1`; in the other, `2`. What’s the story?

* Hidden state: deterministic, we just didn’t know.
* True randomness: the universe rolls dice.
* Many-Worlds: both outcomes occur; your experience is a branch.

**Demo params**

```js
initSudoku("#p4_demo9A", { subRows: 2, subCols: 1, singleSection: true, maxHint: 2, clickToSetAnswer: true });
initSudoku("#p4_demo9B", { subRows: 2, subCols: 1, singleSection: true, maxHint: 2, clickToSetAnswer: true });
```

### 10) Schrödinger’s Sudoku (box inside a box)

Wrap a small Sudoku inside a “room.” Until we open the room, the inner board stays unobserved (our outer variables treat it as a single superposed object). Open the box → collapse inside becomes visible. Close/erase records → restore uncertainty (quantum eraser flavor).

**Demo params**

```js
// outer placeholder
initSudoku("#p4_demo10", { subRows: 1, subCols: 1, singleSection: true });
// on click of the outer cell: dynamically spawn an inner board
initSudoku("#p4_demo10_inner", { subRows: 2, subCols: 2, singleSection: false, clickToSetAnswer: true });
```

---

## Part V — The tree of futures (and the future that writes the past)

### 11) Branching futures while solving

An unsolved puzzle is a branching tree. Each reveal is a cut through possibility space. If a valid solution exists, the branches eventually **converge**. If not, branches proliferate forever—internally consistent local moves, globally inconsistent world.

**Demo params**

```js
initSudoku("#p5_demo11", {
  subRows: 3, subCols: 3, singleSection: false,
  clickToSetAnswer: true, autoHints: true, autosolver: false
});
```

### 12) From future to past: restore superposition from a known finale

Now invert it. Load the **final solved state** (maximum certainty, call it “intelligence”). Then **erase** values at random. Certainty decays into structured superposition; order begets new ignorance. Philosophically: once comprehension reaches a fixed point, it can only continue by **creating uncertainty**—new games to play.

**Demo params**

```js
initSudoku("#p5_demo12", {
  subRows: 3, subCols: 3, singleSection: false,
  clickToSetAnswer: true, autoHints: true, autosolver: true,
  correctValues: /* fullSolution map injected at runtime */,
});
// UI: Entropy slider => erase N random cells; Step Forward => one-hint fill; Step Back => erase 1
```

---

## Part VI — Epilogue: sliding between universes; scripts and cycles

### 13) Sliding between nearby universes

Run three identical boards with the same seed and click in different orders. You’ll **feel** the slide: tiny input differences → different branches. Not teleportation—just adjacent realities diverging smoothly under your fingers.

**Demo params**

```js
["#p6_demo13a", "#p6_demo13b", "#p6_demo13c"].forEach(sel =>
  initSudoku(sel, { subRows: 2, subCols: 2, singleSection: false, clickToSetAnswer: true })
);
```

### 14) Scripted universes and rebirth

If a unique solution exists, the end is written. The start (maximum uncertainty) and the end (maximum certainty) are a matched pair. You can read time in either direction: *solving* or *erasing*. After a full solve, hit “entropy” and start again. Intelligence reaches closure, then—inevitably—bootstraps a fresh unknown.

**Demo params**

```js
// Chain: demo11 (branching) -> demo12 (final→uncertainty) -> back to Part I (single-cell soup)
```

---

## Notes on the analogy

* Real quantum theory is math (Hilbert spaces, operators, POVMs, phases). Sudoku gives *intuitive hooks*: constraints ⇒ correlations; observation ⇒ pruning possibility space; partial information ⇒ decoherence feel.
* Hidden-state Sudoku ≠ quantum indeterminacy. That’s the point: by *contrasting* the two, we get a handle on interpretations.
* Tripartite cases (All-Distinct vs GHZ-like vs W-like) are especially useful. Pairwise intuition breaks; you need to think *globally*.

---

## What’s next

* Swap the parameter blocks for live demos driven by `sudoku.js`.
* Add tiny “state overlays” (counts of hints per cell, entropy meter).
* Record short clips for each concept (15–30s) so the rhythm of collapse/decohere/entangle is obvious even without clicking.

If you want, I’ll stitch this into a single page with **Next/Prev** buttons and load/unload the appropriate `initSudoku(...)` per section so the article literally *plays* like a guided tour.
